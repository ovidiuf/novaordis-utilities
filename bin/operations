#!/bin/bash
#
#
#

debug=false
verbose=false
command=""
declare -a arguments
project_home=""
configuration_file=$(dirname $0)/operations.conf

function usage() {
cat  <<EOF
Nova Ordis Release Tools

Usage:

    <command> [global-options] <command-arguments> | operations [global-options] <command> <command-arguments>

Global Options:

    -v | --verbose - verbose execution.

Commands:

    release <info|snapshot|minor|major|patch|"version-string">

        If 'info' is used, returns the current version information.

        Makes a release by incrementing the release information appropriately, running all tests,
        tagging the repository, building the final artifact and installing the artifact in the
        appropriate artifact repository.

        If 'snapshot' is used, and the current release is a dot release, it will be incremented to
        the next patch snapshot release. If the current release is a snapshot release, the
        snapshot counter will be simply incremented.

        If a version string is used, the string is checked for consistency. The release process
        will fail if the version string is invalid or represents an older version than the current
        version. The repository can be the local Maven repository, a directory, a remote server,
        etc.

        Upon release, the changes will be checked into the source repository, and a
        'release-<version>' tag will be applied, unless the release is a snapshot, in which case the
        repository won't be tagged. The changes will be pushed into the remote repository.

        Also see https://kb.novaordis.com/index.php/Public_Release_Procedure_for_Projects

        Options:

        --no-push - changes won't be pushed into the remote repository. Useful when the release
          process takes place offline. The changes will have to be manually pushed later.

        --no-tests - won't run the test suite upon release. Not usually recommended, unless we're
          releasing a snapshot.

    build

        Build the "releasable" artifact,  which usually is a self-contained, ready-to-install zip.
        In case of a library,  is the JAR file (or the library)  as installed in a repository such
        as Maven.

    install [-f|--force]

         Options:

        --force - overwrites an already installed version.

     test - internal release tools testing shortcut. Advanced users only.

Installation:

    ./src/main/bash/operations install-release-tools <project-home-directory>

        The installation functionality can currently only be accessed from the original
        repository. 'install-release-tools' installs the release tools into the 'bin' subdirectory
        of the specified project home directory. A target directory qualifies as "project home
        directory" if it has a Maven pom.xml in it. If an older version of the release tools is
        already installed, 'install-release-tools' will upgrade in place.

Per-Project Configuration:

    Create an operations.conf in the directory the release tools were installed into and configure local project
    properties.

    Configuration options:

    release_repository - the release repository. Can be LOCAL_MAVEN, a local directory, etc.

EOF
}

function main() {

    #
    # The script is supposed to work both if commands are specified on command line or if we use symbolic links named
    # to match the commands
    #

    identify-command-and-arguments $@

    debug "global debug: ${debug}"
    debug "global verbose: ${verbose}"
    debug "command: ${command}"

    local i=0
    while [ ${i} -lt ${#arguments[*]} ]; do
        debug "arg ${i}: ${arguments[${i}]}"
        ((i++))
    done

    [ "${command}" = "" -o "${arguments[0]}" = "--help" ] && { usage; exit 0; }

    #
    # set project home
    #
    project_home=$(dirname $0)/..

    #
    # load local configuration
    #

    [ -f ${configuration_file} ] && . ${configuration_file}

    #
    # execute the top-level operation, the function expects all its arguments in the "arguments" global array
    #
    do-${command}
}

#
# Activated by --verbose|-v. Relies on a "verbose" global variable
#
function debug
{
    ${verbose} && echo "$@" 1>&2;
    return 0
}

#
# Activated by --verbose|-v. Relies on a "verbose" global variable
#
# Usage:
#        debug-arguments "$@".
#
# It is important to quote the argument, otherwise the empty arguments won't be displayed.
#
function debug-arguments
{
    local first=$1 # placeholder, to avoid IDE warnings
    local args
    if ${verbose}; then
        for arg do
            #
            # this is how we mask passwords
            #
            if [ "--aws-secret-key" = "${arg}" ]; then
                arg="--aws-secret-key ***"
            fi
            [ -z "${arg}" ] && arg="\"\""
            if [ -z "${args}" ]; then
                args="${arg}"
            else
                args="${args}, ${arg}"
            fi
        done
        echo "${FUNCNAME[1]}(${args})" 1>&2;
    fi
    return 0
}

#
# Send error information at stderr and exit. The return code is 255.
#
function fail
{
    echo "[error]: $@" 1>&2 && exit 255
}

# Send warning information at stderr and returns
#
function warn
{
    echo "[warning]: $@" 1>&2
    return 0
}

#
# Send info at stderr (not to interfere with function returns)
#
function info
{
    echo "$@" 1>&2;
    return 0
}

#
# Asks the question and it expects a y/n answer. If the answer starts with 'y', returns 0, otherwise it returns 1
#
function yes
{
    echo -n "$@ [y/n] " 1>&2;
    read line
    [ "${line:0:1}" = "y" ] && return 0 || return 1
}

#
# figures out the command and the arguments. If the method completes successfully, global variable "command" contains
# the command and the global array "arguments" contains the arguments. The function also identifies global options
# such as -v|--verbose, -d|--debug and sets the global variables accordingly - it does not pass those global options
# as arguments to the command function.
#
function identify-command-and-arguments() {

    local name_under_which_we_are_invoked=$(basename $0)

    if [ "${name_under_which_we_are_invoked}" = "operations" ]; then
        debug " we are being called directly, command is among the arguments"
    else
        # we are being called via a symbolic link, the command is the name of the link
        command=${name_under_which_we_are_invoked}
    fi

    #
    # argument loop
    #
    local i=0
    while [ -n "$1" ]; do
        if [ "$1" = "--debug" -o "$1" = "-d" ]; then
            debug=true
        elif [ "$1" = "--verbose" -o "$1" = "-v" ]; then
            verbose=true
        elif [ "${1:0:1}" = "-" ]; then
             # an argument, command cannot start with -
             arguments[${i}]=$1
             ((i++))
        elif [ "${command}" = "" ]; then
             # the first non-switch argument is the command
             command=$1
        else
             arguments[${i}]=$1
             ((i++))
        fi
        shift
    done
}

#
# utilities
#

#
# return the POM project name (<name>)
#
function get-project-name() {

    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    local name
    name=$(grep -m 1 "^ *<name>" ${pom_file})
    [ -z "${name}" ] && fail "<name> not found in ${pom_file}"
    name=${name#*>}
    name=${name%%\<*}
    [ -z ${name} ] && fail "could not extract name from ${pom_file}"
    echo ${name}
}

#
# Returns the project version as specified in the pom.xml file, at stdout
#
function get-version() {

    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"
    local line;
    local artifact_base_name;

    line=$(grep -m 1 "^ *<version>" ${pom_file})
    [ -z "${line}" ] && fail "<version> not found in ${pom_file}"

    local version=${line#*>}
    version=${version%%\<*}
    [ "${version}" = "" ] && fail "could not extract version from ${pom_file}"
    echo ${version}
}

#
# Replaces the version string in pom.xml with the version given as argument, if they are different.
# There are cases when set version is a noop, for example when releasing the current snapshot: the
# POM file already contains the correct version, and subsequent functions will increment it to the
# appropriate post-release "current" version.
#
function set-version() {

    debug-arguments "$@"

    local version=$1
    [ -z "${version}" ] && fail "'version' not specified"

    local pom_file=$2
    [ -z "${pom_file}" ] && pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    local current_version
    current_version=$(get-version) || fail "failed to get the current version from pom.xm"

    if [ "${version}" = "${current_version}" ]; then
        debug "the provided version ${version} and the current pom.xml version are identical"
        return 0
    fi

    #
    # if different, replace the first occurrence of <version>...</version> with our version
    #

    debug "inserting version ${version}"

    local tmp_file=./.tmp

    sed -e '1,/^ *<version>.*<\/version> */s/^\( *<version>\).*\(<\/version> *\)/\1'${version}'\2/' ${pom_file} > ${tmp_file} || \
        fail "failed to perform sed replacement"

    diff -q ${pom_file} ${tmp_file} > /dev/null && fail "no replacement was made in ${pom_file}"
    mv ${tmp_file} ${pom_file} || fail "failed to restore ${pom_file} from ${tmp_file}"
}

#
# gets the current version as declared in POM and computes the version for the release
# being processed. 'mode' can be "major", "minor", "patch", "snapshot" or a full version
# string. If a full version string is provided, the function will verify that is a valid
# version string and the version it specifies if newer than the current version. Sends
# the version string at stdout.
#
function compute-release-version() {

    debug-arguments "$@"

    local current_version=$1
    [ -z "${current_version}" ] && fail "'current_version' not specified"
    local mode=$2
    [ -z "${mode}" ] && fail "'mode' not specified"

    local major
    local minor
    local patch
    local snapshot

    major=$(extract-version-component major ${current_version}) || exit 1
    minor=$(extract-version-component minor ${current_version}) || exit 1
    patch=$(extract-version-component patch ${current_version}) || exit 1
    snapshot=$(extract-version-component snapshot ${current_version}) || exit 1

    debug "major=${major}, minor=${minor}, patch=${patch}, snapshot=${snapshot}"

    if [ "${mode}" = "major" ]; then
        #
        # only increment if we're not a snapshot
        #
        if [ -z "${snapshot}" ]; then
            major=$(expr ${major} + 1) || exit 1
        fi
        minor=""
        patch=""
        snapshot=""
    elif [ "${mode}" = "minor" ]; then

        [ -z "${minor}" ] && minor=0
        if [ -n "${snapshot}" ]; then
            #
            # we're a snapshot
            #
            if [ -n "${patch}" ]; then
                #
                # we're a patch snapshot, so increment the minor
                #
                minor=$(expr ${minor} + 1) || exit 1
            else
                debug "we're a minor snapshot, we don't increment the minor"
                #
                # we're a minor snaps
                #
            fi
        else
            #
            # we're not a snapshot
            #
            minor=$(expr ${minor} + 1) || exit 1
        fi
        patch=""
        snapshot=""
    elif [ "${mode}" = "patch" ]; then
        [ -z "${patch}" ] && patch=0
        #
        # if we're snapshot, keep the patch level
        #
        if [ -z "${snapshot}" ]; then
            patch=$(expr ${patch} + 1) || exit 1
        fi
        snapshot=""
    elif [ "${mode}" = "snapshot" ]; then
        if [ -n "${snapshot}" ]; then
            #
            # the current version is a snapshot, releasing a snapshot means releasing
            # the current snapshot we were working on and incrementing the snapshot
            # number.
            #
            debug "the current snapshot ${snapshot} is being released"
        else
            #
            # current release is a dot release, increment to the next patch snapshot 1
            #
            snapshot=1
            if [ -z "${patch}" ]; then
                patch=1
                if [ -z "${minor}" ]; then
                    minor=0
                fi
            else
                patch=$(expr ${patch} + 1) || exit 1
            fi
        fi
    else
        local new_version=${mode}
        local new_major
        local new_minor
        local new_patch
        local new_snapshot
        new_major=$(extract-version-component major ${new_version}) || exit 1
        new_minor=$(extract-version-component minor ${new_version}) || exit 1
        new_patch=$(extract-version-component patch ${new_version}) || exit 1
        new_snapshot=$(extract-version-component snapshot ${new_version}) || exit 1

        #
        # this is where new version consistency verifications are done
        #

        [ ${new_major} -lt ${major} ] && \
            fail "the major component (${new_major}) of the new version ${new_version} is older then the corresponding major component of the current version ${current_version}"

        if [ ${new_major} -eq ${major} ]; then
            #
            # we must compare minor versions
            #
            [ -z "${new_minor}" ] && new_minor_for_comparison=0 || new_minor_for_comparison=${new_minor}
            [ -z "${minor}" ] && minor_for_comparison=0 || minor_for_comparison=${minor}
            [ "${new_minor_for_comparison}" -le "${minor_for_comparison}" ] && \
                fail "the minor component (${new_minor_for_comparison}) of the new version ${new_version} is equal or older than the corresponding minor component of the current version ${current_version}"

            if [ ${new_minor_for_comparison} -eq ${minor_for_comparison} ]; then
                #
                # we must compare patch versions
                #
                [ -z "${new_patch}" ] && new_patch_for_comparison=0 || new_patch_for_comparison=${new_patch}
                [ -z "${patch}" ] && patch_for_comparison=0 || patch_for_comparison=${patch}
                [ "${new_patch_for_comparison}" -le "${patch_for_comparison}" ] && \
                    fail "the patch component (${new_patch_for_comparison}) of the new version ${new_version} is equal or older than the corresponding patch component of the current version ${current_version}"

                if [ ${new_patch_for_comparison} -eq ${patch_for_comparison} ]; then
                    #
                    # we must compare snapshot versions
                    #
                    if [ -z "${new_snapshot}" ]; then
                        debug "we end a snapshot series with the 'clean' version"
                    else
                        [ -z "${new_snapshot}" ] && new_snapshot_for_comparison=0 || new_snapshot_for_comparison=${new_snapshot}
                        [ -z "${snapshot}" ] && snapshot_for_comparison=0 || snapshot_for_comparison=${snapshot}
                        [ "${new_snapshot_for_comparison}" -le "${snapshot_for_comparison}" ] && \
                            fail "the snapshot component (${new_snapshot_for_comparison}) of the new version ${new_version} is equal or older than the corresponding snapshot component of the current version ${current_version}"
                    fi
                fi
            fi
        fi

        #
        # verification passed
        #

        major=${new_major}
        minor=${new_minor}
        patch=${new_patch}
        snapshot=${new_snapshot}
    fi

    assemble-version-string "${major}" "${minor}" "${patch}" "${snapshot}"
}

#
# gets the current version as declared in POM and computes the next patch snapshot.
#

function compute-next-version() {

    debug-arguments "$@"

    local current_version=$1
    [ -z "${current_version}" ] && fail "'current_version' not specified"

    local major
    local minor
    local patch
    local snapshot

    major=$(extract-version-component major ${current_version}) || exit 1
    minor=$(extract-version-component minor ${current_version}) || exit 1
    patch=$(extract-version-component patch ${current_version}) || exit 1
    snapshot=$(extract-version-component snapshot ${current_version}) || exit 1

    debug "major=${major}, minor=${minor}, patch=${patch}, snapshot=${snapshot}"

    #
    # we calculate the next logical snapshot
    #
    if [ -n "${snapshot}" ]; then
        #
        # we're a snapshot, increment it
        #
        snapshot=$(expr ${snapshot} + 1) || exit 1
    else
        #
        # we're not a snapshot, increment the version to the next patch and initiate snapshot 1
        #
        if [ -z "${patch}" ]; then
            patch=1
        else
            patch=$(expr ${patch} + 1) || exit 1
        fi
        [ -z "${minor}" ] && minor=0
        snapshot=1
    fi
    assemble-version-string "${major}" "${minor}" "${patch}" "${snapshot}"
}

# gets the full version string and returns requested component (major, minor, patch or snapshot).
# They can only be numbers. If not numbers, the method will fail.
# If the component is absent, the method will stdout the empty string
function extract-version-component {

    local mode=$1
    [ -z "${mode}" ] && fail "'mode' not specified"
    [ ${mode} != "major" -a ${mode} != "minor" -a ${mode} != "patch" -a ${mode} != "snapshot" ] && \
        fail "unknown mode ${mode}, must be one of 'major', 'minor', 'patch' or 'snapshot'"
    local version=$2
    [ -z "${version}" ] && fail "'version' not specified"
    local original_version_string=${version}

    local snapshot
    local major
    local minor
    local patch

    local pre_snapshot=${version%-SNAPSHOT*}

    if [ "${version}" != "${pre_snapshot}" ]; then
        #
        # snapshot version
        #
        snapshot=${version#*SNAPSHOT-}
        if ! expr ${snapshot} + 1 >/dev/null 2>&1; then
            fail "the snapshot component of the version string ${original_version_string} (${snapshot}) is not an integer, version string not valid"
        fi
        version=${pre_snapshot}
    fi

    major=${version%%.*}

    if [ "${major}" != "${version}" ]; then
        # there is a dot, the major version is already extracted and stored in 'major', extract the rest
        version=${version#*.}
        minor=${version%%.*}
        if [ "${minor}" != "${version}" ]; then
            # there is a dot, the minor version is already extracted and stored in 'minor', the rest, without the dot, is the patch
            patch=${version#*.}
            [ "${patch}" = "" ] && \
                fail "no patch information follows after the last dot in ${original_version_string}, version string not valid"
            if ! expr ${patch} + 1 >/dev/null 2>&1; then
                fail "the patch component of the version string ${original_version_string} (${patch}) is not an integer, version string not valid"
            fi
        fi
        if ! expr ${minor} + 1 >/dev/null 2>&1; then
            fail "the minor component of the version string ${original_version_string} (${minor}) is not an integer, version string not valid"
        fi
    fi

    if ! expr ${major} + 1 >/dev/null 2>&1; then
        fail "the major component of the version string ${original_version_string} (${major}) is not an integer, version string not valid"
    fi

    if [ "${mode}" = "major" ]; then
        echo ${major}
    elif [ "${mode}" = "minor" ]; then
        echo ${minor}
    elif [ "${mode}" = "patch" ]; then
        echo ${patch}
    elif [ "${mode}" = "snapshot" ]; then
        echo ${snapshot}
    else
        fail "invalid mode ${mode}"
    fi
}

function assemble-version-string() {

    debug-arguments "$@"

    local major=$1
    local minor=$2
    local patch=$3
    local snapshot=$4

    [ -z "${major}" ] && fail "no major version specified"
    if ! expr ${major} + 1 >/dev/null 2>&1; then
        fail "the major component ${major} is not an integer"
    fi

    local version=${major}

    if [ -n "${minor}" ]; then
        if ! expr ${minor} + 1 >/dev/null 2>&1; then
            fail "the minor component ${minor} is not an integer"
        fi
        version=${version}.${minor}
        if [ -n "${patch}" ]; then
            if ! expr ${patch} + 1 >/dev/null 2>&1; then
                fail "the patch component ${patch} is not an integer"
            fi
            version=${version}.${patch}
        fi
    else
       [ -n "${patch}" ] && fail "no minor component provided while a patch component was provided: ${patch}"
    fi

    if [ -n "${snapshot}" ]; then
        if ! expr ${snapshot} + 1 >/dev/null 2>&1; then
            fail "the snapshot component ${snapshot} is not an integer"
        fi
        version=${version}-SNAPSHOT-${snapshot}
    fi

    echo ${version}
}

#
# returns the artifact extension as specified in the pom.xml file or fails if it cannot extract it
#
function get-artifact-extension() {

    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"
    local line;
    line=$(grep -m 1 "^ *<packaging>" ${pom_file})
    [ -z "${line}" ] && fail "<packaging> not found in ${pom_file}"

    local extension=${line#*>}
    extension=${extension%%\<*}
    [ "${extension}" = "" ] && fail "could not extract extension from ${pom_file}"
    echo ${extension}
}

#
# returns the artifact base name from pom.xml by reading 'finalName' (if exists) or 'artifactId' if 'finalName'
# does not exist. The base name does not contain any version or extension information.
#
function get-artifact-base-name()
{
    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"
    local line;
    local artifact_base_name;

    # first try 'finalName' ...
    line=$(grep -m 1 "^ *<finalName>" ${pom_file})
    if [ -z "${line}" ]; then
        # ... then try 'artifactId'.
        line=$(grep -m 1 "^ *<artifactId>" ${pom_file})
        [ -z "${line}" ] && fail "<artifactId> not found in ${pom_file}"
    fi
    artifact_base_name=${line#*>}
    artifact_base_name=${artifact_base_name%%\<*}
    [ -z "${artifact_base_name}" ] && fail "could not extract artifact base name from ${pom_file}"
    echo ${artifact_base_name}
}

#
# returns the artifact file name (not the path), as it will be generated by Maven, including base name, optionally
# version and extension. It's either 'finalName' + extension (if exists) or 'artifactId' + version + extension.
# If built, the artifact file name is typically located under ${project_home}/target
#
function get-artifact-file-name()
{
    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    local prefix
    local postfix=".$(get-artifact-extension)"

    # first try 'finalName' ...
    prefix=$(grep -m 1 "^ *<finalName>" ${pom_file})
    if [ -z "${prefix}" ]; then
        # ... then 'artifactId'
        prefix=$(grep -m 1 "^ *<artifactId>" ${pom_file})
        postfix="-$(get-version).$(get-artifact-extension)"
    fi

    [ -z "${prefix}" ] && fail "<artifactId> not found in ${pom_file}"

    prefix=${prefix#*>}
    prefix=${prefix%%\<*}
    [ -z "${prefix}" ] && fail "failed to extract artifact file prefix from ${pom_file}"
    echo ${prefix}${postfix}
}

function get-release-zip-file-name() {
    echo "$(get-artifact-base-name)-$(get-version).zip"
}

#
# return the application-specific run wrapper name. Usually is the application's "short name", which is called
# from command line. Conventionally, is the POM project name
#
function get-run-wrapper-name() {
    echo $(get-project-name)
}

#
# gets the final location (pre-zip) of the directory containing the run wrapper, identifies the run wrapper
# and configures it (main class, etc).
#
function configure-run-wrapper()
{
    debug-arguments "$@"

    local zip_bin_dir=$1

    [ -z "${zip_bin_dir}" ] && fail "'zip_bin_dir' not provided"
    [ -d ${zip_bin_dir} ] || fail "'zip_bin_dir' ${zip_bin_dir} not a directory"

    #
    # identify the run wrapper
    #

    local run_wrapper_file

    for i in $(ls ${zip_bin_dir}); do
        debug "looking at ${zip_bin_dir}/${i} ..."
        if grep -q "^main_class=\${main_class}" ${zip_bin_dir}/${i}; then
            [ -n "${run_wrapper_file}" ] && fail "two run wrapper files found: ${run_wrapper_file}, ${zip_bin_dir}/${i}"
            run_wrapper_file=${zip_bin_dir}/${i}
        fi
    done

    [ -z "${run_wrapper_file}" ] && fail "no run wrapper file found in ${zip_bin_dir} (or none of the following files: [$(ls ${zip_bin_dir})] contains a main=class= line ...)"

    debug "run wrapper file: ${run_wrapper_file}"

    local main_class
    main_class=$(find-main-class) || exit 1
    debug "main_class: ${main_class}"

    local tf=${project_home}/target/sed.tmp
    sed -e 's/^main_class=\${main_class}.*$/main_class='"${main_class}"'/' ${run_wrapper_file} > ${tf} || fail "failed to sed into ${tf}"
    if diff ${run_wrapper_file} ${tf} > /dev/null; then
        fail "${run_wrapper_file} and ${tf} are identical, no substitution has been made"
    fi

    mv ${project_home}/target/sed.tmp ${run_wrapper_file} && \
        debug "main_class set to '${main_class}' in ${run_wrapper_file}" || \
        fail "failed to mv ${project_home}/target/sed.tmp ${run_wrapper_file}"
}

#
# heuristics to find the main class of the application. Returns the main class in the format "com.example.Main"
# If the project declares a dependency on clad, it assumes the main class is provided by clad, otherwise it brute-force
# recursively searches for a "public static void main"
#
function find-main-class()
{
    local pom_file=${project_home}/pom.xml
    [ -f ${pom_file} ] || fail "pom.xml file ${pom_file} not found"

    if grep -q  "<groupId>io\.novaordis\.clad</groupId>" ${pom_file}; then
        echo "io.novaordis.clad.CommandLineApplication"
        return 0
    fi

    local src_dir=${project_home}/src/main
    local line
    line=$(grep -r "public static void main" ${src_dir}/* | head -n 1) || fail "failed to grep ${src_dir}/*"
    debug "line: ${line}"

    [ -z "${line}" ] && fail "did not find 'public static void main' in ${src_dir}/*"

    local file
    file=${line%%:*}
    debug "file: ${file}"
    [ -f ${file} ] || fail "file ${file} does not exist"

    local package
    package=$(grep "^package.*;" ${file} | sed -e 's/^package \(.*\);.*$/\1/') || fail "failed to grep/sed for package"
    debug "package: ${package}"
    [ -z "${package}" ] && fail "failed to identify the package name in ${file}"

    local class_name
    class_name=$(grep "^public class " ${file} | sed -e 's/^public class \(.*\)/\1/' | tr -d '\012' | tr -d '\015') || fail "failed to grep/sed for class name"
    class_name=${class_name%% *}
    debug "class_name: >${class_name}<"
    [ -z "${class_name}" ] && fail "failed to identify the class name in ${file}"

    echo "${package}.${class_name}"
}

function get-dependencies()
{
    local maven_quiet="-q"
    ${verbose} && maven_quiet=""
    (cd ${project_home}; mvn ${maven_quiet} dependency:build-classpath -Dmdep.pathSeparator=" " -Dmdep.outputFile=./target/dependencies.txt 1>&2) && debug "executed mvn ${maven_quiet} dependency:build-classpath -Dmdep.pathSeparator=\" \" -Dmdep.outputFile=./target/dependencies.txt" || exit 1
    cat ${project_home}/target/dependencies.txt
}

#
# We don't check whether it exists or not, we just build it. If it exists, we overwrite it.
#
# returns the newly created zip file path
#
function build-release-zip-file() {

    debug-arguments $@

    [ -z ${project_home} ] && fail "global variable 'project_home' not defined"

    local artifact_path=${project_home}/target/$(get-artifact-file-name)

    [ ! -f ${artifact_path}  ] && fail "project artifact $(get-artifact-file-name) not found - build the project manually"

    local zip_file_base_name=$(get-artifact-base-name)-$(get-version)
    local zip_root_dir=${project_home}/target/${zip_file_base_name}

    if [ -d ${zip_root_dir} ]; then
        rm -r ${zip_root_dir} && info "deleted zip root directory ${zip_root_dir}" || fail "failed to delete zip root directory ${zip_root_dir}"
    fi

    mkdir ${zip_root_dir} && \
        debug "created zip root directory ${zip_root_dir}" || \
        fail "failed to create zip root directory ${zip_root_dir}"
    mkdir ${zip_root_dir}/lib && \
        debug "created zip root directory ${zip_root_dir}/lib" || \
        fail "failed to create zip root directory ${zip_root_dir}/lib"
    mkdir ${zip_root_dir}/bin && \
        debug "created zip root directory ${zip_root_dir}/bin" || \
        fail "failed to create zip root directory ${zip_root_dir}/bin"
    cp ${artifact_path} ${zip_root_dir}/lib && \
        debug "copied $(basename ${artifact_path}) in ${zip_root_dir}/lib" || exit 1;

    # copy the processed resource files into lib
    for i in ${project_home}/src/main/resources/*; do
        i=$(basename ${i})
        cp ${project_home}/target/classes/${i} ${zip_root_dir}/lib && \
            debug "${project_home}/target/classes/${i} in ${zip_root_dir}/lib" || exit 1;
    done

    cp ${project_home}/src/main/bash/* ${zip_root_dir}/bin && \
        debug "copied scripts to ${zip_root_dir}/bin" || exit 1;
    configure-run-wrapper ${zip_root_dir}/bin && \
        debug "successfully configured the run wrapper" || exit 1;
    chmod a+rx ${zip_root_dir}/bin/* && \
        debug "chmod a+rx ${zip_root_dir}/bin/*" || exit 1;
    cp ${project_home}/README.md ${zip_root_dir} && \
        debug "copied ${project_home}/README.md ${zip_root_dir}/" || exit 1;

    local dependencies
    dependencies=$(get-dependencies) || exit 1
    debug "dependencies: ${dependencies}"
    for i in ${dependencies}; do
        [ -f ${i} ] || fail "dependency ${i} does not exist"
        cp ${i} ${zip_root_dir}/lib && \
            debug "copied dependency ${i} in ${zip_root_dir}/lib" || exit 1;
    done

    local zip_quiet="-q"
    ${verbose} && zip_quiet=""

    local zip_file_name=${zip_file_base_name}.zip
    (cd ${project_home}/target; zip ${zip_quiet} -r ${zip_file_name} ${zip_file_base_name}) 1>&2 && \
        debug "created ${project_home}/target/${zip_file_name}" || \
        exit 1

    echo ${project_home}/target/${zip_file_name}
}

#
# Expands the zip file and installs the application locally in the system directory where third-party software is
# installed (such as /opt or /usr/local). The the version is already installed, fail unless the 'force' argument is
# set to true
#
# returns the home directory of the installed application
#
function install()
{
    debug-arguments "$@"

    local zip_file=$1
    local target_dir=$2 # the system directory where third-party software is installed (/opt or /usr/local)
    local force=$3 # if not specified, defaults to "false"

    [ -z ${zip_file} ] && fail "${FUNCNAME[0]}: no zip file name provided"
    [ -z ${target_dir} ] && fail "${FUNCNAME[0]}: no target directory name provided"
    [ -d ${target_dir} ] || fail "${FUNCNAME[0]}: target directory ${target_dir} does not exist"
    [ -z ${force} ] && force=false

    local application_home_dir=${target_dir}/$(basename ${zip_file} .zip)
    debug "application_home_dir: ${application_home_dir}"

    if [ -d ${application_home_dir} ]; then

        ! ${force} && fail "${application_home_dir} already installed. Use '-f' or '--force' to overwrite"

        # --force was used, remove the existing directory for a clean installation
        rm -r ${application_home_dir} && \
            debug "removed existing ${application_home_dir}" || \
            fail "failed to remove existing ${application_home_dir}"
    fi

    local unzip_quiet="-q"
    ${verbose} && unzip_quiet=""

    unzip ${unzip_quiet} ${zip_file} -d ${target_dir} && \
        debug "unzipped ${zip_file} into ${target_dir}" || \
        fail "failed to unzip ${zip_file} into ${target_dir}"

    local link_name=$(basename ${zip_file} .zip)
    link_name=${link_name%%-[0-9]*} # be prepared to handle <name>-1.0.0, <name>-1.0.0-SNAPSHOT, etc.
    debug "link_name: ${link_name}"

    if [ -h ${target_dir}/${link_name} ]; then
        rm ${target_dir}/${link_name} && \
            debug "removed existing link ${target_dir}/${link_name}" || \
            fail "failed to remove existing link ${target_dir}/${link_name}"
    fi

    # prefer relative links, this increases the chance they'll work over NFS
    (cd ${target_dir}; ln -s ./$(basename ${application_home_dir}) ${link_name}) && \
        debug "linked ./$(basename ${application_home_dir}) to ${link_name}" || \
        fail "failed to link ./$(basename ${application_home_dir}) to ${link_name}"

    echo "${application_home_dir}"
}

#
# Installs the release into repository.
#
# Relies on the presence of 'release_repository' in scope, which should be a project local configuration. If not set,
# the function fails.
#
function install-release() {

    debug-arguments "$@"

    local release_file_path=$1
    [ -z "${release_file_path}" ] && fail "'release_file' not provided"
    [ -f ${release_file_path} ] || fail "the release file ${release_file_path} does not exist"

    debug "release repository: ${release_repository}"

    if [ -z "${release_repository}" ]; then
        info "no 'release_repository' defined in ${configuration_file}, the binary release available as ${release_file_path} ..."
        return 0
    fi

    local target_file=${release_repository}/$(basename ${release_file_path})

    [ -f ${target_file} ] && fail "${target_file} already exists in the repository"

    cp ${release_file_path} ${target_file} && \
        info "installed $(basename ${target_file}) in ${release_repository}" || \
        fail "failed to install $(basename ${target_file}) in ${release_repository}"
}

# return 0 if the configured release_repository is LOCAL_MAVEN
function is-local-maven-release() {

    if [ -z "${release_repository}" ]; then
        #
        # no ${release_repository} defined, that means we'll handle the binary artifact manually
        #
        return 1
    fi

    [ "${release_repository}" = "LOCAL_MAVEN" ] && return 0 || return 1
}

########################################################################################################################
# top level operations, exposed as external commands - they expect the arguments in the "arguments" global array
########################################################################################################################

#
# expects all its arguments in the "arguments" global array
#
function do-install-release-tools() {

    local project_home=${arguments[0]};
    [ "${project_home}" = "" ] && fail "specify the home directory of the project to install the release tools into ..."

    # sanity check - make sure the directory we're installing into is a project - it must have a pom.xml

    local pom_file=${project_home}/pom.xml

    [ -f ${pom_file} ] || fail "${project_home} does not seem to be the home of a project, there is no pom.xml file in it."

    info "installing NovaOrdis release tools into ${project_home} ..."

    local bin_dir=${project_home}/bin
    if [ ! -d ${bin_dir} ]; then
        mkdir ${bin_dir} && info "created ${bin_dir}" || fail "failed to create ${bin_dir}"
    fi

    # copy ourselves into bin - we will overwrite an existing "operations" file and that allows us to easily upgrade
    cp $0 ${bin_dir} && info "copied $0 into ${bin_dir}" || fail "failed to copy $0 into ${bin_dir}"

    # copy the sample configuration file
    if [ ! -f ${bin_dir}/operations.conf ]; then
        cp $(dirname $0)/operations.conf ${bin_dir} && \
            info "copied $(dirname $0)/operations.conf into ${bin_dir}" || \
            fail "failed to copy $(dirname $0)/operations.conf into ${bin_dir}"
    fi

    #
    # these are the links to ./operations that are going to be created in ./bin
    #
    local links="release build install test";
    # create symbolic links
    (cd ${bin_dir}; \
        for link in ${links}; \
        do if [ ! -h ${link} ]; then \
                ln -s $(basename $0) ${link} && \
                    info "linked ./$(basename $0) as ./${link}" || \
                    fail "failed to link ./$(basename $0) as ./${link}"; \
           fi \
        done \
    )

    # create the run wrapper target directory and turn the run wrapper template into the final run script for the
    # application

    local run_wrapper_dir=${project_home}/src/main/bash
    if [ ! -d ${run_wrapper_dir} ]; then
        mkdir -p ${run_wrapper_dir} && \
            info "created ${run_wrapper_dir}" || \
            fail "failed to create ${run_wrapper_dir}"
    fi

    local run_wrapper_template=$(dirname $0)/run-wrapper-template
    local run_wrapper_name
    run_wrapper_name=$(get-run-wrapper-name) || exit 1
    local run_wrapper_path=${run_wrapper_dir}/${run_wrapper_name}

    if [ -f ${run_wrapper_path} ]; then
        warn "run wrapper ${run_wrapper_path} already exists, won't overwrite. Do it manually if required."
    else
        cp ${run_wrapper_template} ${run_wrapper_path} && \
            info "copied ${run_wrapper_template} as ${run_wrapper_path}" || \
            fail "failed to copy ${run_wrapper_template} as ${run_wrapper_path}"
        chmod a+x ${run_wrapper_path} && \
            debug "chmod a+x ${run_wrapper_path}" || \
            fail "failed to chmod a+x ${run_wrapper_path}"
    fi

    #
    # initialize the version mechanism
    #

    if [ ! -d ${project_home}/src/main/resources ]; then
        mkdir -p ${project_home}/src/main/resources || fail "failed to mkdir -p ${project_home}/src/main/resource"
    fi

    local release_date
    local version
    if [ ! -f ${project_home}/src/main/resources/VERSION ]; then
        (cat << EOF
version=\${version}
release_date=\${release_date}
EOF
) > ${project_home}/src/main/resources/VERSION
    fi
}

#
# expects all its arguments in the "arguments" global array
#
function do-release() {

    #
    # process arguments
    #

    local mode # 'snapshot'|'minor'|'major'|'patch' or version string

    #
    # options:
    #
    #  --no-push
    #  --no-tests
    #

    local do_push_option=true
    local run_tests_option=true

    local i=0
    while [ ${i} -lt ${#arguments[*]} ]; do
        local arg=${arguments[${i}]}
        debug "do-release arg ${i}: ${arg}"
        if [ -z "${mode}" ]; then
            mode=${arg}
        fi
        if [ "${arg:0:2}" = "--" ]; then
            if [ "--no-push" = ${arg} ]; then
                do_push_option=false
            elif [ "--no-tests" = ${arg} ]; then
                run_tests_option=false
            else
                fail "unknown option: ${arg}"
            fi
        fi
        ((i++))
    done

    debug "do_push_option: ${do_push_option}"

    #
    # checking pre-requisites
    #

    [ -z "${mode}" ] && fail "info|snapshot|minor|major|patch or the version string must be specified"

    local current_version
    current_version=$(get-version) || exit 1
    debug "current version: ${current_version}"

    if [ "${mode}" = "info" ]; then
        # report the current version and exit
        info "current version: ${current_version}"
        return 0
    fi

    local release_version
    release_version=$(compute-release-version "${current_version}" "${mode}") || exit 1

    debug "release version ${release_version}"

    yes "releasing ${release_version}, is this OK?" || { info "release canceled, no files were changed"; return 0; }

    set-version ${release_version}

    #
    # run the tests with the new version
    #

    if ${run_tests_option}; then
        mvn clean test || fail "test suite failed after version increment, manual intervention required"
    fi

    #
    # tag repository
    #

    git add . && info "git add ok" || fail "git add . failed"

    #
    # there may be nothing to commit, so we don't fail on commit failure, we just warn
    #

    git commit -m "release ${release_version}" && info "git commit ok" || warn "git commit did not succeed, maybe because there was nothing to commit"

    local tag=release-${release_version}
    local tagged

    if [[ ${tag} =~ SNAPSHOT ]]; then
        #
        # only tag repository if we're not a snapshot
        #
        info "current release is a snapshot, won't tag the repository"
        tagged=false
    else
        git tag -m "release ${release_version}" "${tag}" && info "git tag ok, tagged with ${tag}" || fail "git tag failed"
        tagged=true
    fi

    if ${do_push_option}; then
        git push --follow-tags && info "git push ok" || fail "git push failed"
    else
        info "got --no-push, we don't push to the remote repository"
    fi

    local release_binary_artifact
    local maven_testing_configuration=""
    ! ${run_tests_option} &&  maven_testing_configuration="-Dmaven.test.skip=true"

    if is-local-maven-release; then
        mvn ${maven_testing_configuration} clean install || \
            fail "failed to pass tests, must restore the version in pom.xml to ${current_version} manually"

        release_binary_artifact=${project_home}/target/$(get-artifact-file-name)
        [ -f ${release_binary_artifact} ] || \
            fail "release binary artifact ${release_binary_artifact} not found, something went wrong with the maven build process"

    else
        #
        # we need to do install and not package because we may need the JAR in the Maven repository as well
        #
        mvn ${maven_testing_configuration} clean install || \
            fail "failed to pass tests, must restore the version in pom.xml to ${current_version} manually"
        release_binary_artifact=$(build-release-zip-file) || exit 1
        install-release ${release_binary_artifact}
    fi

    #
    # increment locally to the next patch snapshot
    #
    current_version=$(get-version)
    local next_local_version
    next_local_version=$(compute-next-version "${current_version}" snapshot) || exit 1
    debug "next local version ${next_local_version}"

    yes "setting next local version ${next_local_version}, is this OK?" || return 0;
    set-version ${next_local_version}

    local msg="A new ${mode} version (${release_version}) was released"

    if ${tagged}; then
        msg="${msg}, committed to repository and tagged."
    else
        msg="${msg} and committed to repository."
    fi

    info ""
    info "RELEASE SUMMARY:"
    info ""
    info ${msg}
    info "If you want to create an official GitHub release, use tag \"${tag}\" and binary $(basename ${release_binary_artifact})."
    info "The local version has been incremented to ${next_local_version}."
    info ""
}

#
# expects all its arguments in the "arguments" global array
#
function do-build() {

    #
    # process arguments
    #

    #
    # options:
    #
    #  --
    #

    local force=false

    local i=0
    while [ ${i} -lt ${#arguments[*]} ]; do
        local arg=${arguments[${i}]}
        debug "do-build arg ${i}: ${arg}"
        ((i++))
    done

    local release_zip_file_path
    release_zip_file_path=$(build-release-zip-file) || exit 1
}

#
# expects all its arguments in the "arguments" global array
#
function do-install() {

    #
    # process arguments
    #

    #
    # options:
    #
    #  --force
    #

    local force=false

    local i=0
    while [ ${i} -lt ${#arguments[*]} ]; do
        local arg=${arguments[${i}]}
        debug "do-install arg ${i}: ${arg}"
        if [ "${arg}" = "-f" -o "${arg}" = "--force" ]; then
            force=true
        fi
        ((i++))
    done

    #
    # checking pre-requisites
    #

    [ -z ${RUNTIME_DIR} ] && fail "RUNTIME_DIR environment variable not set, don't know where to install"

    debug "building the releasable artifact ..."
    local release_zip_file_path
    release_zip_file_path=$(build-release-zip-file) || exit 1

    local installed_path
    installed_path=$(install ${release_zip_file_path} ${RUNTIME_DIR} ${force}) || exit 1

    info "installed $(basename ${installed_path}) in $(dirname ${installed_path})"
}

function do-test() {

    compute-next-version ${arguments[0]} ${arguments[1]}
}

main $@